# terraform-pipeline.yml - Spezialisierte Terraform CI/CD Pipeline
# Include-Template fÃ¼r fokussierte Terraform-Workflows

# ================================================
# TERRAFORM-SPEZIFISCHE STAGES
# ================================================

stages:
  - terraform-init
  - terraform-validate  
  - terraform-plan
  - terraform-apply
  - terraform-output

# ================================================
# TERRAFORM VARIABLES
# ================================================

variables:
  # Terraform-spezifische Konfiguration
  TF_VERSION: "1.6.6"
  TF_IN_AUTOMATION: "true"
  TF_INPUT: "false"
  TF_CLI_ARGS: "-no-color"
  
  # Backend-Konfiguration
  TF_HTTP_ADDRESS: "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/terraform/state/${CI_ENVIRONMENT_NAME}"
  TF_HTTP_LOCK_ADDRESS: "${TF_HTTP_ADDRESS}/lock"
  TF_HTTP_UNLOCK_ADDRESS: "${TF_HTTP_ADDRESS}/lock"
  TF_HTTP_USERNAME: "gitlab-ci-token"
  TF_HTTP_PASSWORD: "${CI_JOB_TOKEN}"
  TF_HTTP_LOCK_METHOD: "POST"
  TF_HTTP_UNLOCK_METHOD: "DELETE"
  TF_HTTP_RETRY_WAIT_MIN: "5"

# ================================================
# TERRAFORM BASE TEMPLATE
# ================================================

.terraform: &terraform
  image:
    name: hashicorp/terraform:${TF_VERSION}
    entrypoint: [""]
  cache:
    key: "terraform-${CI_COMMIT_REF_SLUG}"
    paths:
      - .terraform/
      - .terraform.lock.hcl
  before_script:
    # Terraform Version Info
    - terraform version
    
    # Backend-Konfiguration
    - |
      cat > backend.conf <<EOF
      address=${TF_HTTP_ADDRESS}
      lock_address=${TF_HTTP_LOCK_ADDRESS}
      unlock_address=${TF_HTTP_UNLOCK_ADDRESS}
      username=${TF_HTTP_USERNAME}
      password=${TF_HTTP_PASSWORD}
      lock_method=${TF_HTTP_LOCK_METHOD}
      unlock_method=${TF_HTTP_UNLOCK_METHOD}
      retry_wait_min=${TF_HTTP_RETRY_WAIT_MIN}
      EOF
    
    # Environment-spezifische Variablen
    - export TF_VAR_environment="${CI_ENVIRONMENT_NAME:-dev}"
    - export TF_VAR_project_name="${CI_PROJECT_NAME}"
    - export TF_VAR_repository_url="${CI_PROJECT_URL}"
    - export TF_VAR_gitlab_token="${GITLAB_TOKEN}"

# ================================================
# TERRAFORM INIT
# ================================================

terraform-init:
  <<: *terraform
  stage: terraform-init
  script:
    - terraform init -backend-config=backend.conf
    - terraform workspace list
    - terraform workspace select "${CI_ENVIRONMENT_NAME}" || terraform workspace new "${CI_ENVIRONMENT_NAME}"
  artifacts:
    paths:
      - .terraform/
      - .terraform.lock.hcl
    expire_in: 1 hour
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

# ================================================
# TERRAFORM VALIDATION
# ================================================

terraform-format-check:
  <<: *terraform
  stage: terraform-validate
  script:
    - terraform fmt -check -recursive -diff
  needs: ["terraform-init"]
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
  allow_failure: false

terraform-syntax-validate:
  <<: *terraform
  stage: terraform-validate
  script:
    - terraform validate
  needs: ["terraform-init"]
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
  allow_failure: false

terraform-security-scan:
  image: checkmarx/kics:latest
  stage: terraform-validate
  script:
    - kics scan -p . -t terraform --report-formats sarif --output-path kics-results
  artifacts:
    reports:
      sast: kics-results/results.sarif
    paths:
      - kics-results/
    expire_in: 1 week
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
  allow_failure: true

# ================================================
# TERRAFORM PLAN
# ================================================

.terraform-plan: &terraform-plan
  <<: *terraform
  stage: terraform-plan
  script:
    # Plan with environment-specific variables
    - terraform plan -var-file="terraform-${CI_ENVIRONMENT_NAME}.auto.tfvars" -out="plan-${CI_ENVIRONMENT_NAME}.tfplan" -detailed-exitcode
    
    # Generate JSON output for GitLab
    - terraform show -json "plan-${CI_ENVIRONMENT_NAME}.tfplan" > "plan-${CI_ENVIRONMENT_NAME}.json"
    
    # Plan Summary
    - |
      echo "=== Terraform Plan Summary for ${CI_ENVIRONMENT_NAME} ==="
      terraform show "plan-${CI_ENVIRONMENT_NAME}.tfplan" | head -50
  artifacts:
    paths:
      - "plan-${CI_ENVIRONMENT_NAME}.tfplan"
      - "plan-${CI_ENVIRONMENT_NAME}.json"
    expire_in: 1 week
    reports:
      terraform: "plan-${CI_ENVIRONMENT_NAME}.json"
  needs: ["terraform-init"]

terraform-plan-dev:
  <<: *terraform-plan
  environment:
    name: dev
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

terraform-plan-staging:
  <<: *terraform-plan
  environment:
    name: staging
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
  needs: ["terraform-init", "terraform-plan-dev"]

terraform-plan-prod:
  <<: *terraform-plan
  environment:
    name: prod
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      when: manual
  needs: ["terraform-init", "terraform-plan-staging"]

# ================================================
# TERRAFORM APPLY
# ================================================

.terraform-apply: &terraform-apply
  <<: *terraform
  stage: terraform-apply
  script:
    # Pre-Apply Validation
    - echo "Applying Terraform configuration for ${CI_ENVIRONMENT_NAME}"
    - terraform workspace select "${CI_ENVIRONMENT_NAME}"
    
    # Apply with plan file
    - terraform apply "plan-${CI_ENVIRONMENT_NAME}.tfplan"
    
    # Generate outputs
    - terraform output -json > "outputs-${CI_ENVIRONMENT_NAME}.json"
    
    # Apply Summary
    - |
      echo "=== Terraform Apply Summary for ${CI_ENVIRONMENT_NAME} ==="
      echo "Resources created/updated:"
      terraform show -json | jq -r '.values.root_module.resources[].address'
  artifacts:
    paths:
      - "outputs-${CI_ENVIRONMENT_NAME}.json"
    expire_in: 1 month
  resource_group: $CI_ENVIRONMENT_NAME

terraform-apply-dev:
  <<: *terraform-apply
  environment:
    name: dev
    url: https://$CI_PROJECT_NAME-dev.example.com
    deployment_tier: development
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      when: on_success
  needs: ["terraform-plan-dev"]

terraform-apply-staging:
  <<: *terraform-apply
  environment:
    name: staging
    url: https://$CI_PROJECT_NAME-staging.example.com
    deployment_tier: staging
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      when: manual
  needs: ["terraform-plan-staging"]

terraform-apply-prod:
  <<: *terraform-apply
  environment:
    name: prod
    url: https://$CI_PROJECT_NAME.example.com
    deployment_tier: production
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      when: manual
      allow_failure: false
  needs: ["terraform-plan-prod"]
  before_script:
    - !reference [.terraform, before_script]
    # Production-spezifische Validierung
    - echo "ðŸš¨ PRODUCTION DEPLOYMENT - ZusÃ¤tzliche Validierung"
    - echo "Environment: ${CI_ENVIRONMENT_NAME}"
    - echo "Commit: ${CI_COMMIT_SHA}"
    - echo "Pipeline: ${CI_PIPELINE_URL}"

# ================================================
# TERRAFORM OUTPUT STAGE
# ================================================

terraform-output:
  <<: *terraform
  stage: terraform-output
  script:
    # Alle Environment-Outputs sammeln
    - |
      echo "=== Terraform Outputs ==="
      for env in dev staging prod; do
        if [ -f "outputs-${env}.json" ]; then
          echo "--- Environment: $env ---"
          jq -r '. | to_entries[] | "\(.key): \(.value.value)"' "outputs-${env}.json"
        fi
      done
    
    # Connection Details extrahieren
    - |
      if [ -f "outputs-${CI_ENVIRONMENT_NAME}.json" ]; then
        echo "=== Connection Details for ${CI_ENVIRONMENT_NAME} ==="
        jq -r '.connection_details.value | to_entries[] | "\(.key): \(.value)"' "outputs-${CI_ENVIRONMENT_NAME}.json" || echo "No connection details found"
      fi
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
  needs:
    - job: terraform-apply-dev
      optional: true
    - job: terraform-apply-staging  
      optional: true
    - job: terraform-apply-prod
      optional: true

# ================================================
# TERRAFORM DESTROY (CLEANUP)
# ================================================

.terraform-destroy: &terraform-destroy
  <<: *terraform
  stage: terraform-apply
  script:
    - echo "ðŸ”¥ DESTROYING Terraform resources for ${CI_ENVIRONMENT_NAME}"
    - terraform workspace select "${CI_ENVIRONMENT_NAME}"
    - terraform destroy -var-file="terraform-${CI_ENVIRONMENT_NAME}.auto.tfvars" -auto-approve
  environment:
    name: $CI_ENVIRONMENT_NAME
    action: stop
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      when: manual
  allow_failure: true

terraform-destroy-dev:
  <<: *terraform-destroy
  environment:
    name: dev
    action: stop
  needs: ["terraform-apply-dev"]

terraform-destroy-staging:
  <<: *terraform-destroy
  environment:
    name: staging
    action: stop
  needs: ["terraform-apply-staging"]

terraform-destroy-prod:
  <<: *terraform-destroy
  environment:
    name: prod
    action: stop
  needs: ["terraform-apply-prod"]
  before_script:
    - !reference [.terraform, before_script]
    - echo "ðŸš¨ðŸ”¥ PRODUCTION DESTROY - EXTREME CAUTION REQUIRED"
    - echo "This will destroy ALL production resources!"
    - sleep 10

# ================================================
# COST ESTIMATION
# ================================================

terraform-cost-estimate:
  image: infracost/infracost:latest
  stage: terraform-plan
  before_script:
    - infracost auth login --api-key $INFRACOST_API_KEY
  script:
    # Cost estimation fÃ¼r alle Environments
    - |
      for env in dev staging prod; do
        if [ -f "plan-${env}.json" ]; then
          echo "=== Cost Estimate for $env ==="
          infracost diff --path "plan-${env}.json" --format table --show-skipped
          infracost diff --path "plan-${env}.json" --format json --out-file "cost-${env}.json"
        fi
      done
  artifacts:
    paths:
      - cost-*.json
    expire_in: 1 week
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
  needs:
    - job: terraform-plan-dev
      optional: true
    - job: terraform-plan-staging
      optional: true  
    - job: terraform-plan-prod
      optional: true
  allow_failure: true

# ================================================
# DRIFT DETECTION (SCHEDULED)
# ================================================

terraform-drift-detection:
  <<: *terraform
  stage: terraform-plan
  script:
    - terraform workspace select "${CI_ENVIRONMENT_NAME}"
    - terraform plan -var-file="terraform-${CI_ENVIRONMENT_NAME}.auto.tfvars" -detailed-exitcode
  rules:
    - if: $CI_PIPELINE_SOURCE == "schedule"
  parallel:
    matrix:
      - CI_ENVIRONMENT_NAME: [dev, staging, prod]
  allow_failure: true